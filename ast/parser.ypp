%{
	#include <stdio.h>
    	#include "ast.hpp"
    	#include "primitive.hpp"
    	#include "symtab.hpp"
	#define YYDEBUG 1

    	extern Program_ptr ast;
	int yylex(void);
	void yyerror(const char *);
%}

/* Enables verbose error messages */
%error-verbose




/*********************************************************
	Replace with your code from project 2
*********************************************************/
%start Start

%token BOOL
%token ELSE
%token IF
%token INT
%token FOR
%token VAR
%token FUNCTION
%token INTARRAY
%token RETURN

%token EQEQ
%token GT
%token GTE
%token LT
%token LTE
%token NE
%token ANDAND
%token OROR
%token NOT
%token PLUS
%token MINUS
%token TIMES
%token DIVIDE

%token TRUE
%token FALSE

%token IDENTIFIER
%token INTEGER

%token SEMICOLON
%token COLON
%token COMMA
%token ABSOLUTEVALUE
%token LEFTBRACE
%token RIGHTBRACE
%token LEFTPAREN
%token RIGHTPAREN
%token LEFTBRACKET
%token RIGHTBRACKET
%token ASSIGNMENT


%left OROR
%left ANDAND
%left EQEQ NE
%left GT GTE LT LTE
%left PLUS MINUS
%left TIMES DIVIDE

%right ASSIGNMENT
%right NOT

%%

Start : F FUNC_ { $2.u_func_list->push_front($1.u_func); ast=new ProgramImpl($2.u_func_list); }
        ;

FUNC_ : F FUNC_ { $2.u_func_list->push_front($1.u_func); $$.u_func_list= $2.u_func_list;}
        | { $$.u_func_list=new list<Func_ptr>(); }
        ;

F : FUNCTION IDENTIFIER LEFTPAREN P_L RIGHTPAREN COLON TYPE LEFTBRACE B_O_F RIGHTBRACE { $$.u_func=new FuncImpl($7.u_type,new SymName($2.u_base_charptr),$4.u_decl_list,$9.u_function_block); }
        ;

P_L : IDENTIFIER COLON TYPE MORE_PARAMS { $1.u_symname_list=new list<SymName_ptr>(); $1.u_symname_list->push_back(new SymName($1.u_base_charptr)); $4.u_decl_list->push_front(new DeclImpl($3.u_type,$1.u_symname_list)); $$.u_decl_list=$4.u_decl_list; }
      | {$$.u_decl_list=new list<Decl_ptr>();} 
      ;

MORE_PARAMS : COMMA P_L {$$.u_decl_list=$2.u_decl_list;}
            | {$$.u_decl_list=new list<Decl_ptr>();}
            ;

TYPE :    INT   {$$.u_type=new TInteger();}
        | BOOL  {$$.u_type=new TBoolean();}
        ;

TYPE_2 : TYPE {$$.u_type=$$.u_type;}
        | INT_ARRAY {$$.u_type = $1.u_type;}
        ;

INT_ARRAY : INTARRAY LEFTBRACKET INTEGER RIGHTBRACKET {$$.u_type=new TIntArray(new Primitive($3.u_base_int));}
          ;
INT_ARRAY_EXP: IDENTIFIER LEFTBRACKET EXPR_ESSION RIGHTBRACKET {$$.u_expr=new ArrayAccess(new SymName($1.u_base_charptr),$3.u_expr); }
             ;


B_O_F : VAR_DECLERATIONS BODY_CHOICE RETURN_ {$$.u_function_block=new Function_blockImpl($1.u_decl_list,NULL,NULL,$3.u_return);}
        ;

BODY_CHOICE : MULT_FUNCTIONS BODY_STATEMENTS
              ;
MULT_FUNCTIONS: F MULT_FUNCTIONS
              |
              ;
BODY_STATEMENTS : STATEMENTS_ BODY_STATEMENTS
                |
                ;

VAR_DECLERATIONS : VAR_DEC VAR_DECLERATIONS   { $2.u_decl_list->push_front($1.u_decl); $$.u_decl_list=$2.u_decl_list;  }
                 | {$$.u_decl_list=new list<Decl_ptr>();}
                 ;

VAR_DEC : VAR IDENTIFIER MULT_DEC COLON TYPE_2 SEMICOLON { $3.u_symname_list->push_front(new SymName($1.u_base_charptr)); $$.u_decl=new DeclImpl($5.u_type,$3.u_symname_list); }
         ;

MULT_DEC :   COMMA IDENTIFIER MULT_DEC {$3.u_symname_list->push_front(new SymName($2.u_base_charptr)); $$.u_symname_list=$3.u_symname_list; }
            | {$$.u_symname_list=new list<SymName_ptr>();}
            ;

STATEMENTS_ : ASIGN_MENT SEMICOLON
             | FUNCTION_CALL SEMICOLON
             | IF_
             | IF_ELSE
             | FOR_
             ;

RETURN_ : RETURN EXPR_ESSION SEMICOLON {$$.u_return=new ReturnImpl($2.u_expr);}
          ;

IF_ : IF LEFTPAREN EXPR_ESSION RIGHTPAREN LEFTBRACE BODY_STATEMENTS RIGHTBRACE

IF_ELSE : IF_ ELSE LEFTBRACE BODY_STATEMENTS RIGHTBRACE

FOR_ : FOR LEFTPAREN FOR_PARAMS RIGHTPAREN LEFTBRACE BODY_STATEMENTS RIGHTBRACE
            ;

FOR_PARAMS : FOR_ASIGN LEFTPAREN EXPR_ESSION RIGHTPAREN FOR_ASIGN
            ;

FOR_ASIGN : ASIGN_MENT SEMICOLON
             |
             ;

ASIGN_MENT : IDENTIFIER ASSIGNMENT EXPR_ESSION
            | INT_ARRAY_EXP ASSIGNMENT EXPR_ESSION
            ;

EXPR_ESSION : MULT_EXPRESSION {$$.u_expr=$1.u_expr;}
            | LEFTPAREN EXPR_ESSION RIGHTPAREN OPE_RATOR
            | NOT LEFTPAREN EXPR_ESSION RIGHTPAREN OPE_RATOR
            | ABSOLUTEVALUE EXPR_ESSION ABSOLUTEVALUE OPE_RATOR
            ;

SINGLE_EXPRESSION : MINUS INTEGER %prec NOT {$$.u_expr=new Uminus(new IntLit(new Primitive($2.u_base_int)));}
                  | INTEGER         {$$.u_expr=new IntLit(new Primitive($1.u_base_int)); }
                  | TRUE            {$$.u_expr=new BoolLit(new Primitive($1.u_base_int));}
                  | FALSE           {$$.u_expr=new BoolLit(new Primitive($1.u_base_int));}
                  | IDENTIFIER      { $$.u_expr=new Ident(new SymName($1.u_base_charptr));}
                  | INT_ARRAY_EXP   {$$.u_expr=$1.u_expr;}
                  | NOT SINGLE_EXPRESSION
                  ;

                  
MULT_EXPRESSION : SINGLE_EXPRESSION OPE_RATOR
                  ;

OPE_RATOR :
                  | PLUS EXPR_ESSION
                  | MINUS EXPR_ESSION
                  | TIMES EXPR_ESSION
                  | DIVIDE EXPR_ESSION
                  | OROR EXPR_ESSION
                  | ANDAND EXPR_ESSION
                  | EQEQ EXPR_ESSION
                  | GT EXPR_ESSION
                  | GTE EXPR_ESSION
                  | LT EXPR_ESSION
                  | LTE EXPR_ESSION
                  | NE EXPR_ESSION
                  ;

FUNCTION_CALL : IDENTIFIER ASSIGNMENT IDENTIFIER LEFTPAREN IN_PARAMS RIGHTPAREN
                | INT_ARRAY_EXP ASSIGNMENT IDENTIFIER LEFTPAREN IN_PARAMS RIGHTPAREN
                ;

IN_PARAMS : EXPR_ESSION NEXT_PARAM
                |
                ;

NEXT_PARAM : COMMA IN_PARAMS
            |
            ;


%%
/*********************************************************
	Stop here
*********************************************************/




extern int yylineno;

void yyerror(const char *s) {
	fprintf(stderr, "%s at line %d\n", s, yylineno);
	return;
}
